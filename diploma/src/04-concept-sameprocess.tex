
Einzelschrittausführung und Breakpoints bilden die zentralen Ablaufkontrollmechanismen in Trace-Debuggern (\ref{sec:context-debugging-trace}). Es folgt eine allgemeine Betrachtung zur Realisierbarkeit dieser Mechanismen für Same-Process Debugger unter den speziellen Anforderungen der Echtzeitverarbeitung.

\subsection{Breakpoints}
\label{sec:concept-sameprocess-breakpoints}

%\subsection{Variable Befehlslänge}
\label{sec:concept-sameprocess-overwriting}

Die Befehle der x86 Befehlssatzarchiektur haben keine einheitliche Länge. Insbesondere ist ein \emph{Call} Befehl, der zur Übertragung des Kontrollflusses an den Debugger verwendet werden soll (Breakpoint), länger als verschiedene andere Befehle. Damit kann es zum partiellen oder vollständigen Überschreiben von Folgebefehlen durch Breakpoints kommen. Handelt es sich bei einem solchen Folgebefehl um ein Sprungziel, ändert das die Semantik des Programms. Abbildung \ref{fig:breakpoint} stellt diese Problematik grafisch dar. 

\begin{figure}[htb]
  \centering
  \includegraphics[width=0.5\textwidth]{04-breakpoint.png} %[scale=0.25]
  \caption{Beispiel für das Überschreiben von Folgebefehlen durch Breakpoints. Die Befehle A, B, C und D liegen im Speicher unmittelbar hintereinander. Nach A wird entweder B oder D ausgeführt (oben). Beim Setzen eines Breakpoints auf B wird ein Teil des Befehls D überschrieben (unten). Dies ändert die Programmsemantik, da D erreicht werden kann, bevor dessen ursprünglicher Befehlscode wiederhergestellt wurde.}
  \label{fig:breakpoint}
\end{figure}

\noindent
Der obere Teil der Abbildung zeigt die vier im Speicher unmittelbar aufeinanderfolgenden Befehle A, B, C und D. Beim Befehl A handelt es sich um einen bedingten Sprungbefehl. Ist die Sprungbedingung erfüllt, wird die Ausführung im Anschluss bei Befehl D fortgesetzt. Damit ist D ein Sprungziel im dargestellten Programm. Ist die Sprungbedingung nicht erfüllt, wird der im Speicher nachfolgende Befehl B ausgeführt. Die Befehle B, C und D sollen einfache sequenzielle Operationen ausführen. Der untere Teil der Abbildung zeigt eine Situation, in der auf Befehl B ein Breakpoint gesetzt wurde, der länger ist als der Befehl selbst. Der Breakpoint überschreibt C vollständig und D partiell. Das Überschreiben von C ist unproblematisch, da vor C stets B ausgeführt wird. Erreicht die Ausführung den Breakpoint, wird der ursprüngliche Maschinencode von C wiederhergestellt. Dies ist bei Befehl D nicht der Fall. Da D ein Sprungziel ist, besteht die Möglichkeit, dass die Ausführung D erreicht, während ein Teil des Befehls von dem Breakpoint auf dem Befehl B überlappt wird. Der durch diese Überlappung verfälschte Befehlscode kommt im Beispiel genau dann zur Ausführung, wenn die Sprungbedingung von A erfüllt ist. Der Breakpoint ändert damit die Semantik des Programms. Für diese Problematik sollen im Folgenden zwei Lösungsansätze vorgestellt werden.

\subsubsection{Lösung durch Ausrichtung der Maschinenbefehle}
\label{sec:concept-sameprocess-overwriting-align}

Eine einfache Lösung wäre das Nachahmen der einheitlichen Befehlslänge der SPARC Befehlssatzarchitektur. Der Compiler könnte alle Maschinenbefehle auf ganzzahlige Vielfache der Länge eines Calls ausrichten. Jede entstehende Lücke könnte durch einen NOP\footnote{Bei der Verarbeitung eines NOP Befehls ("`No-OPeration"') wird vom Prozessor keine Operation ausgeführt. In der x86 Befehlssatzarchitektur ist der NOP Befehl genau ein Byte lang \cite{Intel2}.} bzw. Multi-Byte-NOP\footnote{Multi-Byte-NOPs werden durch normale Befehle simuliert, die so parametrisiert sind, dass sie nicht zur Veränderung des Ausführungszustandes führen. Vorschläge für entsprechende Befehle werden in \cite{Intel2} für verschiedene Befehlslängen gegeben.} Befehl gefüllt werden. Beide werden im Folgenden unter der Bezeichnung \emph{NOP} zusammengefasst. Breakpoints könnten weiterhin nur auf die ursprünglichen Befehle gesetzt werden. Sollte der zu ersetzende Befehl kürzer sein als der einzufügende Call, würde im Zweifel nur der darauffolgende NOP überschrieben. Dabei handelt es sich nur um Behelfscode, der kein Sprungziel sein kann. Das Problem wäre damit behoben. Für den Einsatz in der digitalen Signalverarbeitung ist diese Lösung ist jedoch ungeeignet. Die Gründe dafür liegen in dem damit verbundenen, vergleichsweise hohen Laufzeitoverhead. Die Ausrichtung aller Maschinenbefehle führt zur annähernden Verdopplung der Gesamtbefehlsmenge. Der überwiegende Teil der eingefügten NOPs folgt auf sequenzielle Befehle und kommt daher in jedem Verarbeitungsdurchlauf zur Ausführung. Zwar können NOP Befehle vom Prozessor i.\,A. in wenigen Takten verarbeitet werden, doch führt dies bei komplexen Verarbeitungsaufgaben zu einem erkennbaren Overhead. Dieser erhöht sich noch durch die Effekte, die durch die zusätzliche Streuung des Maschinencodes im Speicher entstehen. Da gerade häufig verwendete Operationen eine besonders geringe Befehlslänge aufweisen, kommt es zu einer Vervielfachung des für den Programmcode erforderlichen Speicherplatzes. Dies hat Konsequenzen wie größere Distanzen für Sprünge, eine verringerte Cache-Effizienz und nicht zuletzt die Gefahr von Page-Faults. 

\newpage
\subsubsection{Lösung durch Einteilung in sequenzielle Befehlsblöcke}
\label{sec:concept-sameprocess-overwriting-blocks}

Optimierungen in DSP-Programmen zielen oft auf die Minimierung der Anzahl von Sprüngen im Maschinencode\footnote{Für den Signalverarbeitungsvorgang haben Sprünge keinen direkten Nutzen. Zudem führen bedingte Sprünge oft zu Pipeline-Stalls im Prozessor und drosseln damit die Ausführungsgeschwindigkeit von Programmen.}. Es ergeben sich oft lange sequenzielle Befehlsfolgen. Vor diesem Hintergrund erscheint es sinnvoll, den Maschinencode des Prüflings als Abfolge \emph{sequenzieller Befehlsblöcke} zu betrachten. Sequenzielle Befehlsblöcke bilden eine Erweiterung des Standardkonzepts von \emph{Grundblöcken} im Compilerbau \cite{Compiler}. Ein sequenzieller Befehlsblock beginnt stets an einem Sprungziel und umfasst alle Maschinenbefehle bis zum nächsten Sprungziel. Beginn und Ende des Maschinencodes begrenzen jeweils den ersten und letzten sequenziellen Befehlsblock. Jeder Maschinenbefehl des Prüflingsprogramms ist damit genau einem sequenziellen Befehlsblock zugeordnet. Die Verarbeitung eines sequenziellen Befehlsblocks beginnt stets mit der ersten Anweisung (dem Sprungziel) und setzt sich unter Einhaltung der sequenziellen Befehlsreihenfolge im Speicher fort. Bis zu dieser Stelle gleichen sequenzielle Befehlsblöcke den Grundblöcken im Compilerbau. Der Unterschied besteht darin, dass Sprunganweisungen in sequenziellen Befehlsblöcken an beliebigen Stellen enthalten sein können. Damit muss die Ausführung nicht notwendigerweise das Ende eines sequenziellen Befehlsblocks erreichen. %Hier unterscheiden sich sequenzielle Befehlsblöcke vom Standardkonzept der \emph{Grundblöcke} im Compilerbau. 

Die sequenzielle Ausführungsreihenfolge innerhalb der Befehlsblöcke ermöglicht das koordinierte Einfügen und Entfernen von Breakpoints, da im Vorfeld bekannt ist, in welcher Reihenfolge sie getroffen werden. Ein Breakpoint wird damit nicht notwendigerweise sofort in den Maschinencode des Prüflings eingefügt. Im Hinblick auf die Terminologie soll in dieser Arbeit das \emph{Setzen} die Registrierung des Breakpoints gegenüber dem Debugger bezeichnen. Das \emph{Implementieren} eines Breakpoints entspricht dem Einfügen des entsprechenden Call Befehls im Maschinencode. 

Es genügt, zunächst nur den jeweils ersten Breakpoint eines sequenziellen Befehlsblocks zu implementieren. Dies stellt die Ausgangssituation dar. Sie muss immer dann vorliegen, wenn die Ausführung den Befehlsblock erreicht. Im Zuge der Unterbrechung, die von einem Breakpoint ausgelöst wird, wird zunächst der ursprüngliche Maschinencode des gesamten sequenziellen Befehlsblocks wiederhergestellt und der darauffolgende Breakpoint implementiert. Die Ausführung wird an der Stelle des ursprünglichen Maschinenbefehls des getroffenen Breakpoints fortgesetzt. 

Da die Ausführung den sequenziellen Befehlsblock jedoch an beliebigen Stellen verlassen kann, ist nicht sichergestellt, dass die nachfolgenden Breakpoints auch getroffen werden. Somit ist nicht klar, wann der erste Breakpoint erneut implementiert werden muss, um die Ausgangssituation wiederherzustellen. Der erste Breakpoint eines sequenziellen Befehlsblocks nimmt daher eine Sonderstellung ein. Es muss sichergestellt sein, dass er erneut implementiert wird, bevor die Ausführung den sequenziellen Befehlsblock verlässt. Dies kann analog zur Vorgehensweise herkömmlicher Debugger (siehe \ref{sec:context-debugging-separate-breakpoints}) nach der Ausführung eines impliziten Einzelschritts erfolgen. Implizite Einzelschritte stellen einen Behelfsmechanismus dar, um den Kontrollfluss erneut an den Debugger zu übertragen. Sie führen nicht zu einer sichtbaren Unterbrechung der Ausführung\footnote{Sollte durch einen impliziten Einzelschritt eine Stelle im Maschinencode erreicht werden, für die ein Breakpoint gesetzt ist, muss dies vom Debugger erkannt werden. Dann wird zusätzlich zur Behelfsfunktion des impliziten Einzelschritts eine sichtbare Unterbrechung erforderlich.}. 
Hier besteht jedoch die Möglichkeit, dass der Breakpoint nach dem Einzelschritt noch nicht erneut implementiert werden kann. Dies ist der Fall, wenn der durch den Einzelschritt erreichte Folgebefehl noch innerhalb des vom ersten Breakpoint überlappten Speicherbereichs liegt. Demzufolge müssen solange implizite Einzelschritte ausgeführt werden, bis ein Befehl erreicht wird, der nicht mehr vom ersten Breakpoint des Befehlsblocks überlappt wird. Zu diesem Zeitpunkt kann der erste Breakpoint erneut implementiert werden. Alle nachfolgenden Breakpoints des sequenziellen Befehlsblocks werden dann, wie eingangs beschrieben, sukzessive implementiert. Für diese Breakpoints sind keine impliziten Einzelschritte erforderlich, da vor ihnen stets der erste Breakpoint getroffen wird, wenn die Ausführung den sequenziellen Befehlsblock erneut erreicht.

%Erreicht die Ausführung diesen Breakpoint, wird zuerst der ursprüngliche Maschinencode des Prüflings wiederhergestellt. Nach der Unterbrechung erfolgt die Implementierung des jeweils nächsten Breakpoints analog zur Vorgehensweise in herkömmlichen Debuggern in \ref{sec:context-debugging-separate-breakpoints} nach der Ausführung eines impliziten Einzelschritts. Da es sich bei diesem Einzelschritt nur um einen Behelfsmechanismus handelt, sollte er implizit erfolgen und damit keine erneute Unterbrechung der Ausführung bewirken. Gibt es hinter der Speicherstelle des vorigen Breakpoints innerhalb des sequenziellen Befehlsblocks einen weiteren Breakpoint, wird dieser implementiert. Andernfalls wird wieder der erste Breakpoint des sequenziellen Befehlsblocks implementiert. Überlappt er die Stelle des nächsten auszuführenden Maschinenbefehls, müssen weitere implizite Einzelschritte ausgeführt werden. Für das Verfahren ist es damit unerheblich, ob die Ausführung tatsächlich das Ende des sequenziellen Befehlsblocks erreicht oder ihn durch einen Sprungbefehl bereits zuvor verlässt.

%Diese Vorgehensweise ist genau dann unproblematisch, wenn der erste Breakpoint die Speicherstelle des letzten nicht überlappt. Sollte dies jedoch der Fall sein, kann der erste Breakpoint des sequenziellen Befehlsblocks erst dann erneut implementiert werden, wenn der ursprüngliche Maschinenbefehl an der Speicherstelle des letzten Breakpoints bereits ausgeführt wurde. Analog zur Vorgehensweise in herkömmlichen Debuggern kann diese Problematik durch die Ausführung eines Einzelschrittes gelöst werden (\ref{sec:context-debugging-separate-breakpoints}). Dieser Einzelschritt ist ein Behelfsmechanismus und muss implizit erfolgen. Er sollte also keine Unterbrechung der Ausführung bewirken. Reihenfolgeprobleme beim Einfügen und Entfernen sich gegenseitig überlappender Calls sind damit innerhalb sequenzieller Befehlsblöcke ausgeschlossen. %Zu beachten ist hier der beriffliche Unterschied zwischen dem Setzen und dem Implementieren eines Breakpoints.

Um eine Überlappung über die Grenzen eines sequenziellen Befehlsblocks hinaus zu verhindern, wird vom Compiler zwischen den sequenziellen Befehlsblöcken (und damit vor jedem Sprungziel) jeweils ein Puffer eingefügt. Die Größe des Puffers bemisst sich an der Länge eines Call Befehls. Als Befehlscode in diesem Puffer kommt ein NOP Befehl zum Einsatz. Er kommt nur beim direkten Übergang zweier aufeinanderfolgender sequenzieller Befehlsblöcke zur Ausführung. Die Streuung des Maschinencodes nimmt im Vergleich zu \ref{sec:concept-sameprocess-overwriting-align} nur in geringem Umfang zu. Der resultierende Laufzeitoverhead ist im Hinblick auf die oft langen sequenziellen Befehlsblöcke in DSP-Programmen vertretbar.

%\subsection{Kontrollflussanalyse}
%\label{sec:concept-sameprocess-flow}

\subsubsection{Nachbetrachtung}
\label{sec:concept-sameprocess-overwriting-conclusion}

Bei der Verwendung von Calls zur Realisierung von Breakpoints in Same-Process Debuggern wird eine spezielle Kompilierung des Prüflings nach \ref{sec:concept-sameprocess-overwriting-align} oder \ref{sec:concept-sameprocess-overwriting-blocks} erforderlich. Programmcode, der nicht in dieser Weise präpariert wurde, kann nicht unter Gewährleistung der grundlegenden Prinzipien von Debuggern (\ref{sec:context-debugging-basics}) inspiziert werden. Die Einteilung des Prüflingscodes in sequenzielle Befehlsblöcke erweist sich für DSP-Programme als vorteilhaft und wird nachfolgend verwendet. Für das Einfügen von Puffern im Maschinencode des Prüflings muss der Compiler sämtliche Sprungziele im Programmablauf identifizieren. Diese Daten können auch für das in \ref{sec:concept-sameprocess-stepping} beschriebene Verfahren zur Einzelschrittausführung verwendet werden.

%Breakpoints können sowohl zur Laufzeit als auch während einer Unterbrechung gesetzt werden. 

Im Falle herkömmlicher Debugger wird der Ausführungszustand des Prüflings vor bzw. nach einer Unterbrechung im Zuge des Prozesswechsels vom Betriebssystem automatisch gesichert bzw. wiederhergestellt. Da die Prozesswechsel bei Same-Process Debuggern entfallen, muss die Sicherung und Wiederherstellung des Ausführungszustandes hier manuell erfolgen. 
Das Setzen von Breakpoints auf Sprachebene ist unabhängig vom zugrundeliegenden Realisierungsansatz und kann nach der Vorgehensweise herkömmlicher Debugger erfolgen (\ref{sec:context-debugging-separate-breakpoints}).

Im Gegensatz zum Konzept Kesslers wird der durch einen Breakpoint überschriebene Maschinenbefehl hier nicht innerhalb der Behandlungsroutine ausgeführt. Denn dafür wäre ein erheblicher Mehraufwand für die Umcodierung relativer Sprungdistanzen nötig. Stattdessen wird ein Breakpoint im Zuge der Unterbrechung wieder durch den ursprünglichen Maschinencode ersetzt (im Falle des ersten Breakpoints nur vorübergehend). Nach der Unterbrechung wird die Ausführung nicht am Befehl \emph{nach} dem Breakpoint fortgesetzt, sondern an der Stelle des wiederhergestellten Maschinencodes. Dieses Vorgehen orientiert sich an der Verfahrensweise herkömmlicher Debugger.

%Stattdessen wird der Vorgehensweise herkömmlicher Debugger gefolgt, indem der Breakpoint nach der Unterbrechung vorübergehend entfernt und der ursprüngliche Maschinenbefehl in einem Einzelschritt ausgeführt wird.

%Dafür wird die Zuordnung zwischen den Befehlen auf Source- und Instrution-Level in den Programmdaten verwendet.

%Je nach Art der verwendeten Hochsprache kann es dazu kommen, dass zwei Source-Level-Befehle auf dieselbe Stelle im Maschinencode abgebildet werden. Dies ist z.\,B. der Fall, wenn .. oder der Maschinencode zu Optimierungszwecken transformiert wurde. Zu beachten ist, dass die Reihenfolge der Ersetzungsvorgänge nach dem LIFO Prinzip erfolgen muss: Der zuletzt eingefügte Breakpoint muss als erster wieder entfernt werden. Die Realisierung gestaltet sich besonders einfach, wenn temporäre Breakpoints stets zuletzt eingefügt werden.

%Als Vereinfachung wird im Folgenden angenommen, dass Prüflingsprogramme stets eine rein sequenzielle, beliegig verzweigte Programmstruktur aufweisen. Funktionsaufrufe Schleifen 

\subsection{Einzelschrittausführung}
\label{sec:concept-sameprocess-stepping}

%Ein zentraler Mechanismus von Trace-Debuggern ist die Einzelschrittausführung. 
Die folgende Betrachtung konzentriert sich auf die Realisierung von Instruction-Level-Steps. Source-Level-Steps können dann analog zur Verfahrensweise herkömmlicher Debugger durch wiederholte Instruction-Level-Steps oder Breakpoints realisiert werden (siehe \ref{sec:context-debugging-separate-stepping}). Seperate-Process Debugger verwenden das Trap-Flag des Prozessors für Instruction-Level-Steps. Same-Process Debugger können das Trap-Flag des Prozessors nicht verwenden. Die Einzelschrittausführung kann jedoch mit Hilfe \emph{temporärer Breakpoints} nachgebildet werden. Im Gegensatz zu herkömmlichen, sogenannten \emph{permanenten Breakpoints} werden temporäre Breakpoints nach erfolgter Unterbrechung der Ausführung nicht erneut implementiert. %Temporäre Breakpoints unterliegen ebenfalls dem in Abschnitt \ref{sec:concept-sameprocess-breakpoints} beschriebenen Einfügemechanismus. %Temporäre Breakpoints sollten stets unmittelbar vor Fortsetzung der Ausführung implementiert werden.

\subsubsection{Voraussetzungen}
\label{sec:concept-sameprocess-stepping-preconditions}

Vorausgesetzt wird ein funktionierender Breakpoint-Mechanismus nach \ref{sec:concept-sameprocess-breakpoints}. Zudem werden die Speicheradressen von Sprungbefehlen und deren Sprungziele im Maschinencode des Prüflings benötigt. Diese können entweder vom Debugger durch Befehlsdekodierung an der Stelle einer Unterbrechung gewonnen oder vom Compiler bereitgestellt werden. 

\subsubsection{Ablauf}
\label{sec:concept-sameprocess-stepping-execution}

Wurde die Ausführung des Prüflings an einem Breakpoint unterbrochen, wird zunächst der unveränderte Originalzustand des Prüflings wiederhergestellt (\ref{sec:context-debugging-separate-breakpoints}). Der nächste auszuführende Maschinenbefehl ist der Befehl an der Speicherstelle der Unterbrechung. Dabei kann es sich entweder um einen Sprungbefehl\footnote{Bei Sprungbefehlen kann zudem zwischen bedingten und unbedingten Sprüngen unterschieden werden. Sprungbefehle kommen auch für die Realisierung von Schleifen zum Einsatz. Eine Unterscheidung der verschiedenen Sprungbefehle würde die Betrachtung jedoch unnötig verkomplizieren. Es wird stets von bedingten Sprungbefehlen ausgegangen.} oder um eine beliebige andere Operation handeln. Im Falle eines beliebigen anderen Befehls ist die Ausführung eines Instruction-Level-Steps trivial. Das Setzen eines temporären Breakpoints auf den im Speicher direkt folgenden Maschinenbefehl genügt. Handelt es sich um einen Sprungbefehl, gibt es je nach Auswertung der Sprungbedingung zwei mögliche Folgebefehle: den im Speicher direkt folgenden Maschinenbefehl und den Maschinenbefehl an der Stelle des Sprungziels. Liegen die Daten aller Sprungbefehle und -ziele bereits vor, stellt das Setzen temporärer Breakpoints auf beide mögliche Folgebefehle eine einfache Lösung dar. Andernfalls ist die Dekodierung des Befehlscodes ohnehin erforderlich. Dabei könnte auch das für die Sprungbedingung zuständige Flag gefunden und ausgewertet werden, um den tatsächlichen Folgebefehl vorherzusagen.

Nach erfolgtem Einzelschritt kommt es erneut zu einer Unterbrechung der Ausführung. Da dem Benutzer die Inspektion des ursprünglichen Prüflingscodes möglich sein soll, müssen wie üblich alle Breakpoints für die Dauer der Unterbrechung entfernt werden. Temporäre Breakpoints kommen im hier vorgestellten Konzept nur zum Zweck der Einzelschrittausführung zum Einsatz und müssen nach einer Unterbrechung nicht erneut implementiert werden. Nach einem Einzelschritt können alle temporären Breakpoints daher auch aus der Registrierung im Debugger entfernt werden. Die Vorgehensweise ist hier also unabhängig davon, wie viele temporäre Breakpoints für die Realisierung des Einzelschrittes verwendetet worden sind.

\subsubsection{Überlappungsproblem bei Schleifen}
\label{sec:concept-sameprocess-stepping-loops}

Bei der Verwendung des in \ref{sec:concept-sameprocess-overwriting-blocks} beschriebenen Verfahrens zur Realisierung von Breakpoints kann sich ein solches Einzelschrittverfahren als problematisch erweisen. Die erneute Implementierung des ersten Breakpoints eines sequenziellen Befehlsblocks erfolgt erst nach der Ausführung des ursprünglichen Maschinenbefehls in einem Einzelschritt. Das hier beschriebene Einzelschrittverfahren wird jedoch ebenfalls mit Breakpoints realisiert. Dies ist unproblematisch, solange die möglichen Folgebefehle im Speicher hinter dem auszuführenden Maschinenbefehl liegen. Denn dann kann der auszuführende Maschinenbefehl selbst nicht durch die nötigen temporären Breakpoints überschrieben werden. Im Falle einer Schleife liegt das Sprungziel im Speicher jedoch vor der Sprunganweisung. Die Implementierung eines temporären Breakpoints an der Stelle des Sprungziels könnte damit die auszuführende Sprunganweisung überschreiben. Eine solche Überlappung würde die Programmsemantik ändern. 

%Unter Verwendung des in \ref{sec:concept-sameprocess-overwriting-blocks} beschriebenen Verfahrens zur Realisierung von Breakpoints kann sich ein solches Einzelschrittverfahren für die erneute Implementierung permanenter Breakpoints als problematisch erweisen. Wie dort beschrieben wird, kann der erste Breakpoint eines sequenziellen Befehlsblocks u.\,U. erst dann erneut implementiert werden, wenn der ursprüngliche Maschinenbefehl an der Speicherstelle des letzten Breakpoints des Befehlsblocks bereits ausgeführt wurde. Enthält der Befehlsblock eine Schleife und liegen die beteiligten Breakpoints genau auf der Sprunganweisung zum Schleifenbeginn und dessen Sprungziel (dem Schleifenbeginn selbst), würde für einen Einzelschritt nach dem hier beschriebenen Verfahren ein temporärer Breakpoint an der Speicherstelle des ersten Breakpoints des sequenziellen Befehlsblocks implementiert, \emph{bevor} der ursprüngliche Maschinenbefehl an der Speicherstelle des letzten Breakpoints ausgeführt wurde. 

Abbildung \ref{fig:minimal-loop} zeigt in Teil A ein Beispiel einer solchen Situation\footnote{Angenommen wird ein x86 Befehlssatz und eine Adressbreite von 32 Bit.}. Den Ausgangspunkt bildet der in A.0 dargestellte sequenzielle Befehlsblock, der mit einer Schleife beginnt (Speicherstelle $s_5$). Die dafür verwendete Loop Anweisung dekrementiert den Wert des Zählregisters ECX in jedem Durchlauf \cite{Intel2}. Die Schleife wird verlassen, wenn ECX den Wert Null enthält. Dann wird die Ausführung beim Folgebefehl an der Speicherstelle $s_7$ fortgesetzt. Das Sprungziel im Wiederholungsfall ist die Schleifenanweisung selbst. Nach \ref{sec:concept-sameprocess-overwriting-blocks} wurde vom Compiler vor jedem Sprungziel ein Puffer vorbereitet, der die Länge eines Call Befehls hat (1 Byte Opcode und 4 Byte relative Sprungadresse). In A.1 wurde ein Breakpoint auf den Loop Befehl bei $s_5$ gesetzt. Der ursprüngliche Maschinencode wurde vom Debugger zwischengespeichert und mit einem Call Befehl überschrieben. Wenn die Ausführung den sequenziellen Befehlsblock erreicht (A.2), kommt es zu einer Unterbrechung. Nach der Unterbrechung soll der ursprüngliche Befehl an der Speicherstelle $s_5$ zunächst in einem Einzelschritt ausgeführt werden, um den Breakpoint im Anschluss erneut implementieren zu können\footnote{Der Loop Befehl ist der erste Maschinenbefehl des sequenziellen Segments.}. Wird dieser Einzelschritt wie zuvor beschrieben mit Hilfe temporärer Breakpoints realisiert, müssen Breakpoints auf alle in Frage kommenden Folgebefehle gesetzt werden. Da es sich hier um eine bedingte Sprunganweisung handelt, gibt es zwei mögliche Folgebefehle: den im Speicher nachfolgenden Befehl (an der Stelle $s_7$) und das Sprungziel (an der Stelle $s_5$). Dabei kommt es zu der in A.3 dargestellten Überlappung\footnote{Je nach Reihenfolge der Implementierung könnte der Breakpoint bei $s_5$ auch die ersten drei Byte des Breakpoints bei $s_7$ überschreiben. Dann kommt es zu einer Verfälschung des Befehlscodes beim Verlassen der Schleife.}. Der ursprüngliche Maschinenbefehl an der Stelle des Breakpoints wurde überschrieben.

%\footnote{Da jeder Befehl mindestens ein Byte lang ist, würde auch ein Puffer mit einer Länge von vier Byte ausreichen.}

%die zu einer Verfälschung des Befehlscodes des Breakpoints im Wiederholungsfall führt.
%Dabei soll es sich um den einzigen und damit letzten Breakpoint des sequenziellen Befehlsblocks handeln. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=\textwidth]{04-minimal-loop.png} %[scale=0.25]
  \caption{Beispiel des Überlappungsproblems bei Schleifen. Die Ausgangspunkte bilden die in A.0 und B.0 dargestellten sequenziellen Befehlsblöcke. Beide beginnen mit einer Schleifenanweisung bei $s_5$. Dargestellt sind ebenfalls die vorgelagerten Puffer bei $s_0$. Das Sprungziel der Schleifenanweisung in A.0 ist die Speicherstelle $s_5$ (die Schleifenanweisung selbst). B.0 zeigt die korrigierte Variante. Hier erfolgt der Sprung im Wiederholungsfall zum Maschinenbefehl im Puffer bei $s_0$. Soll im Anschluss an eine Unterbrechung bei $s_5$ (A.2 bzw. B.2) die Ausführung des ursprünglichen Maschinenbefehls in einem Einzelschritt erfolgen, müssen temporäre Breakpoints an den Stellen der möglichen Folgebefehle gesetzt werden. Im Falle des unkorrigierten Sprungbefehls in A wird der ursprüngliche Maschinenbefehl damit überschrieben (A.3). Durch die Korrektur in B kann dies vermieden werden (B.3).}
  \label{fig:minimal-loop}
\end{figure}

%\noindent
Dieser Sonderfall muss separat behandelt werden. Konkret kann die betroffene Sprung\-anweisung so korrigiert werden, dass sie einen Sprung auf den Maschinenbefehl im Puffer vor dem ursprünglichen Sprungziel ausführt. Eine Überlappung ist dann ausgeschlossen. Dies hat keine Auswirkung auf die Programmsemantik des Prüflings, da es sich bei dem Befehl im Puffer nach \ref{sec:concept-sameprocess-overwriting-blocks} ohnehin um einen NOP handelt. Eine solche Korrektur ist stets möglich, da vor jedem Sprungziel immer ein Puffer existiert.

\newpage
\enlargethispage{0.2cm}
\noindent
Der Ablauf unter Verwendung einer solchen Korrektur ist in Teil B von Abbildung \ref{fig:minimal-loop} dargestellt. Der Loop Befehl an der Speicherstelle $s_5$ hat hier $s_0$ als Sprungziel im Wiederholungsfall. Wie in B.3 zu sehen ist, überlappen sich die für den Einzelschritt nötigen Breakpoints hier nicht. Nach erfolgtem Einzelschritt (B.4), wird zunächst der ursprüngliche Maschinencode an den Stellen der temporären Breakpoints wiederhergestellt. Dies führt zur Ausgangssituation in B.0. Im Anschluss kann der permanente Breakpoint bei $s_5$ erneut implementiert werden. Der resultierende Laufzeitoverhead von einem Maschinenbefehl pro Schleifendurchlauf ist im Hinblick auf die Seltenheit einer solchen Situation vertretbar. Die Korrektur der Sprungadresse könnte zudem bereits zur Übersetzungszeit vom Compiler vorgenommen werden.

%\begin{itemize}
%	\item Lösungen: Manuelle Realisierung der Konstrukte zur Ablaufsteuerung (INT3 und Exceptions durch Eigenimplementierung mit Calls)
%	\item Aspekte: Portabilität, Laufzeit-Overhead, Implikationen für Compiler und IDE
%\end{itemize}

%\subsection{Tracking-Points}
%\label{sec:concept-sameprocess-tracking}

%Für die Umleitung des Kontrollflusses vom Prüfling zu einer Routine des Debuggers sind im Falle eines Same-Process Debuggers keine aufwändigen Prozesswechsel erforderlich. Breakpoints könnten damit nicht nur für die Unterbrechung der Ausführung zum Einsatz kommen, sondern auch für die Aufzeichnung des Ausführungsverhaltens des Prüflings. Derartige Breakpoints werden im Folgenden als \emph{Tracking-Points} bezeichnet. Die an einem Tracking-Point aufgerufene Routine des Debuggers könnte gezielt Informationen zum Ausführungsverhalten des Prüflings speichern und den Kontrollfluss im Anschluss unmittelbar an den Prüfling zurückgeben ohne eine Unterbrechung einzuleiten.

%Beispielsweise könnte der Debugger systematisch Tracking-Points an Verzweigungsoperationen im Prüfling implementieren. Zum Zeitpunkt einer tatsächlichen Unterbrechung könnte dann der Verarbeitungsverlauf im Prüfling mit Hilfe der gesammelten Informationen vollständig rekonstruiert werden. Für die Unterstützung des Benutzers bei der Inspektion ließe sich damit auf einfache Weise eine Darstellung der Slime Trail des Prüflings bewerkstelligen (\ref{sec:context-debugging-trace}).

%\subsection{Zusammenfassung}
%\label{sec:concept-sameprocess-conclusion}

%Die vorgestellten Mechanismen für Breakpoints und Einzelschrittausführung ermöglichen die Realisierung der Grundfunkionalitäten eines Trace-Debuggers. Ihre Anwendbarkeit erfordert eine spezielle Kompilierung des Prüflings. Für die Verwendung des favorisierten Breakpoint-Mechanismus' aus Abschnitt \ref{sec:concept-sameprocess-overwriting-blocks} ist eine Ergänzung der Programmdaten um die Adressen der sequenziellen Befehlsblöcke erforderlich. Wird dem Debugger darüber hinaus auch die Abfolge der sequenziellen Befehlsblöcke im Sinne des Kontrollflusses in den Programmdaten übergeben, benötigt der Debugger keine Funktionalitäten zur Befehlsdekodierung für die Ausführung von Einzelschritten nach \ref{sec:concept-sameprocess-stepping}. Asynchrone Unterbrechungen der Ausführung sind nicht möglich.


