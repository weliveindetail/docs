
Zusammenfassend soll im Folgenden die Verbindung der in diesem Kapitel erarbeiteten Konzepte vorgestellt werden. Die Instanziierung des Debuggers sollte spätestens zu Beginn der Kompilierung des Prüflings im Debug-Modus erfolgen. Bei der Instanziierung wird der Speicher des Callback-Flags (\ref{sec:concept-realtime-breakpointinsertion-callbackpoint}) alloziert. Auch die Allokation des Speicherbereichs für den separaten Aufrufstack (\ref{sec:concept-realtime-break-concept}) sollte bereits zur Übersetzungszeit geschehen, damit die spätere Umleitung nicht durch die dafür nötigen Systemaufrufe verzögert wird. Vom Compiler wird zuerst der Programmcode des Callback-Points (\ref{sec:concept-realtime-breakpointinsertion-callbackpoint}) erzeugt. Dabei ist die Angabe der Speicherstelle des Callback-Flags und der behandelnden Routine des Debuggers erforderlich. Bei der Kompilierung des Verarbeitungscodes des Prüflings müssen die sequenziellen Befehlsblöcke im Maschinencode durch die Identifizierung sämtlicher Sprungziele ermittelt werden (\ref{sec:concept-sameprocess-overwriting-blocks}). Vor jedem Sprungziel wird vom Compiler ein Puffer in Form eines NOPs eingefügt. Sind im Maschinencode des Prüflings Schleifen enthalten, müssen deren Sprungziele für den Wiederholungsfall vom Compiler gemäß \ref{sec:concept-sameprocess-stepping-loops} u.\,U. korrigiert werden. 

%Nach Abschluss der Kompilierung werden dem Debugger die Programmdaten des Prüflings zur Verfügung gestellt. Neben der Zuordnung zwischen den Anweisungen auf Source- und Instruction-Level müssen die Programmdaten auch die Adressen der sequenziellen Befehlsblöcke enthalten (\ref{sec:concept-sameprocess-overwriting-conclusion}). 
%Im Anschluss kann die Echtzeitverarbeitung beginnen.

Zur Laufzeit wird der Aufrufstack des Prüflings bei jedem Verarbeitungsdurchlauf am Entkopplungspunkt in den separaten Stackspeicher umgeleitet (\ref{sec:concept-realtime-break-concept}). Während der Ausführung des Prüflings kann der Benutzer in der Entwicklungsumgebung Breakpoints auf Source-Level-Anweisungen setzen. Dies bewirkt das Setzen des Callback-Flags. Im nächsten Verarbeitungsdurchlauf des Prüflings wird damit am Callback-Point eine Behandlungsroutine des Debuggers aufgerufen. Sie setzt zunächst das Callback-Flag zurück und implementiert im Anschluss die gesetzten Breakpoints im Programmcode des Prüflings nach dem in \ref{sec:concept-sameprocess-overwriting-blocks} beschriebenen Verfahren. Danach wird die Echtzeitverarbeitung regulär fortgesetzt. Wird in einem der folgenden Verarbeitungsdurchläufe ein Breakpoint getroffen, wird zunächst der Ausführungszustand des Prüflings gesichert und der ursprüngliche Programmcode wiederhergestellt. Danach erfolgt die Entkopplung des Aufrufstacks, sodass der Funktionsaufruf im Echtzeit-Thread zurückkehren kann und die Stackframes der übersprungenen Funktionen im separaten Stackspeicher verbleiben (\ref{sec:concept-realtime-break-concept}). Die Ausführung des Prüflings ist zu diesem Zeitpunkt unterbrochen. Sein Ausführungszustand kann inspiziert werden. 

Wie in \ref{sec:concept-realtime-break-concept} beschrieben, wird die Fortsetzung der Ausführung von einem Behelfs-Thread übernommen. Dabei wird zunächst der Ausführungszustand des Prüflings wiederhergestellt. Gemäß \ref{sec:concept-sameprocess-overwriting-blocks} müssen die ursprünglichen Befehle an der Stelle des Breakpoints nun u.\,U. in einem oder mehreren impliziten Einzelschritten (\ref{sec:concept-sameprocess-stepping}) ausgeführt werden. Nach der erneuten Implementierung der gesetzten Breakpoints im Programmcode des Prüflings wird die Verarbeitung fortgesetzt. Die Ausführung expliziter Einzelschritte erfolgt unter Verwendung temporärer Breakpoints nach dem in \ref{sec:concept-sameprocess-stepping} beschriebenen Verfahren. Der weitere Ablauf erfolgt analog zur Vorgehensweise bei der Verwendung permanenter Breakpoints.

Erreicht die Ausführung das Ende des Prüflingscodes, werden die Stackframes im separaten Stackspeicher vollständig abgearbeitet. Die Entkopplung ist damit aufgehoben. Die Echtzeitverarbeitung des Prüflings kann wieder aufgenommen werden. %Die Ausführung des Behelfs-Threads kehrt zum Betriebssystem zurück.

%Andernfalls kann die Ausführung eines Einzelschritts entfallen, da die Stelle der nächsten Unterbrechung zu diesem Zeitpunkt bereits bekannt und eine Überlappung ausgeschlossen ist (\ref{sec:concept-sameprocess-overwriting-blocks}). 